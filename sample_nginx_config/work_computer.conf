server {
    # http2 enables the HTTP/2 protocol, which gives you:
    ## * Multiplexing: Multiple requests over a single TCP connection (way faster than HTTP/1.1)
    ## * Header compression: Reduces overhead
    ## * Server push: Can send resources before they're requested (though rarely used)

    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    server_name localhost;

    # If using let's encrypt
    # ssl_certificate /etc/letsencrypt/live/localhost/fullchain.pem;
    # ssl_certificate_key /etc/letsencrypt/live/localhost/privkey.pem;

    # Self-signed
    ssl_certificate     /etc/nginx/ssl/crt_work_computer.pem;
    ssl_certificate_key /etc/nginx/ssl/key_work_computer.pem;
    
    # Security headers
    ## Prevents downgrade attacks
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
    ## Prevents clickjacking
    add_header X-Frame-Options "SAMEORIGIN" always;
    ## Prevents MIME sniffing attacks
    add_header X-Content-Type-Options "nosniff" always;

    location /some_app {
        auth_request /saml/validate;

        auth_request_set $user_email $upstream_http_x_user_email;
        auth_request_set $user_name $upstream_http_x_user_name;
        auth_request_set $user_nameid $upstream_http_x_user_nameid;

        proxy_set_header X-User-Email $user_email;
        proxy_set_header X-User-Name $user_name;
        proxy_set_header X-User-NameId $user_nameid;
        
        error_page 401 = @error401;

        proxy_pass http://localhost:8080/;
        proxy_set_header Host $host; # Passes the original domain name to your backend.
        proxy_set_header X-Real-IP $remote_addr; # The actual client's IP address
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # Chain of proxy IPs. Appends the client IP to any existing XFF header 
        proxy_set_header X-Forwarded-Proto $scheme; # Tells your backend whether the original request was http or https.
    }

    location / {
        proxy_pass http://localhost:8000/;  # or wherever your FastAPI SAML app runs
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # Handle authentication failures
    location @error401 {
        return 302 /saml/login?redirect=$request_uri;
    }
    # Just test
    # location / {
    #     proxy_pass http://localhost:8000;  # or wherever your FastAPI SAML app runs
    #     proxy_set_header Host $host;
    #     proxy_set_header X-Real-IP $remote_addr;
    #     proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    #     proxy_set_header X-Forwarded-Proto $scheme;
    # }

    access_log /var/log/nginx/work_computer_access.log;
    error_log /var/log/nginx/work_computer_error.log;
}

# HTTP redirect
server {
    listen 80;
    listen [::]:80;
    server_name localhost;
    return 301 https://$server_name$request_uri;
}